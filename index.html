<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Intrinsic Value Calculator</title>
  <style>
    body { font-family: Arial; margin: 40px auto; max-width: 600px; background: #fafafa; }
    label { display: block; margin-top: 1em; font-weight: bold; }
    input, button {
      width: 100%; padding: 8px; margin-top: .25em; font-size: 1em;
    }
    button {
      margin-top: 1em; background: #007acc; color: #fff; border: none; cursor: pointer;
    }
    button:hover { background: #005fa3; }
    #result { margin-top: 1.5em; padding: 1em; background: #e0ffe0; border-radius: 4px; }
    #debug  {
      margin-top: 1em; padding: 1em; background: #fff3cd; font-family: monospace;
      white-space: pre-wrap; max-height: 200px; overflow: auto;
    }
  </style>
</head>
<body>
  <h2>üìà Intrinsic Value Calculator (Finnhub)</h2>

  <label for="ticker">Ticker</label>
  <input id="ticker" placeholder="e.g. AAPL" />

  <label for="growth">Est. Growth Rate (%)</label>
  <input id="growth" type="number" placeholder="e.g. 10" />

  <label for="pe">Future PE Ratio</label>
  <input id="pe" type="number" placeholder="e.g. 15" />

  <label for="discount">Discount Rate (%)</label>
  <input id="discount" type="number" placeholder="e.g. 8" />

  <label for="years">Forecast Years</label>
  <input id="years" type="number" value="5" />

  <button onclick="calculate()">Calculate</button>

  <div id="result">üí¨ Results will appear here.</div>
  <div id="debug" hidden>üêû Debug output</div>

  <script>
    const apiKey = "d0kuab9r01qhb02558rgd0kuab9r01qhb02558s0";

    // Always try resp.json(), catch any parse/network errors.
    async function fetchJSON(url) {
      const resp = await fetch(url);
      if (!resp.ok) throw new Error(`Network error: ${resp.status}`);
      try {
        return await resp.json();
      } catch (e) {
        throw new Error("Non-JSON response");
      }
    }

    function parseMetric(v) {
      const n = parseFloat(v);
      return isNaN(n) ? null : n;
    }

    async function fetchFCF(ticker) {
      // 1) Try annual cash-flow
      try {
        const cfUrl = `https://finnhub.io/api/v1/stock/cash-flow?symbol=${ticker}&period=annual&token=${apiKey}`;
        const cfData = await fetchJSON(cfUrl);
        console.log("Cash-flow response:", cfData);
        if (cfData.series?.length) {
          const fcf = parseMetric(cfData.series[0].freeCashFlow);
          if (fcf !== null) {
            return { value: fcf, label: "Free Cash Flow (Annual)" };
          }
        }
      } catch (e) {
        console.warn("cash-flow failed, falling back:", e.message);
      }

      // 2) Fallback to TTM metrics
      const mUrl = `https://finnhub.io/api/v1/stock/metric?symbol=${ticker}&metric=all&token=${apiKey}`;
      const mData = await fetchJSON(mUrl);
      console.log("Metric response:", mData);
      const candidates = {
        "Free Cash Flow (TTM)": parseMetric(mData.metric.freeCashFlowTTM),
        "Net Income (TTM)":    parseMetric(mData.metric.netIncomeTTM),
        "EBITDA (TTM)":        parseMetric(mData.metric.ebitdaTTM)
      };
      for (const [lbl, val] of Object.entries(candidates)) {
        if (val !== null) return { value: val, label: lbl };
      }

      throw new Error("No usable metrics found");
    }

    async function calculate() {
      const t = document.getElementById("ticker").value.trim().toUpperCase();
      const g = parseFloat(document.getElementById("growth").value)  / 100;
      const p = parseFloat(document.getElementById("pe").value);
      const d = parseFloat(document.getElementById("discount").value)/ 100;
      const n = parseInt(  document.getElementById("years").value, 10);
      const res = document.getElementById("result");
      const dbg = document.getElementById("debug");
      dbg.hidden = true;
      res.textContent = "‚è≥ Fetching data‚Ä¶";

      if (!t) {
        res.textContent = "‚ö†Ô∏è Please enter a ticker.";
        return;
      }

      try {
        const { value: baseFCF, label } = await fetchFCF(t);
        let fcf = baseFCF, pv = 0;
        for (let i = 1; i <= n; i++) {
          fcf *= 1 + g;
          pv  += fcf / Math.pow(1 + d, i);
        }
        const term = (fcf * p) / Math.pow(1 + d, n);
        const iv   = pv + term;

        res.innerHTML = `
          ‚úÖ <strong>${t}</strong><br/>
          üîç Metric Used: <em>${label}</em><br/>
          üí∞ Intrinsic Value ‚âà <strong>$${(iv/1e9).toFixed(2)} B</strong>
        `;
      } catch (err) {
        res.textContent = "‚ö†Ô∏è " + err.message;
        dbg.textContent = err.stack;
        dbg.hidden = false;
      }
    }
  </script>
</body>
</html>
